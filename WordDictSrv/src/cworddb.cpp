//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : WordDict
//  @ File Name : cworddb.cpp
//  @ Date : 2015/2/10
//  @ Author : wangqunfeng
//
//
#include <string>
#include <map>
#include <list>
#include <utility>
#include <algorithm>
#include <fstream>
#include <iostream>
#include <regex>
#include "eworderror.hpp"
#include "cworddb.hpp"
#include "cwordconfig.hpp"

using namespace std;

CWordDB::CWordDB()
{
     this->m_dbc = 0;
     this->m_dbn.clear();
     this->m_dbp.clear();
     this->m_db.clear();
}

CWordDB::CWordDB(const std::string& dbn)
{
     this->m_dbc = 0;
     this->m_dbn = dbn;
     this->m_dbp.clear();
     this->m_db.clear();
}

CWordDB::~CWordDB()
{

}

EErrorCode CWordDB::load(const std::string& path)
{
    string each_line;
    ifstream fp(path.c_str());
    const std::regex pattern_word("^[1-9]\\d*,\\s(\\w+)\\s+(\\[.+\\])[\\n\\r]{0,2}$");
    const std::regex pattern_exp("^([vnac]\\w*)\\.\\s+(.+)[\\n\\r]{0,2}$");
    std:: match_results<std::string::const_iterator> match_result;
    string word;
    list<string> exp;

    if(!fp.good())
    {
        fp.close();
        return E_ISERR;
    }

    while(fp.good())
    {
        std::getline(fp, each_line);
        if(each_line.empty())
            continue;
        if(regex_match(each_line, match_result, pattern_word))
        {
            //flush buffer before store new word&exp
            if(!word.empty() && !exp.empty())
            {
                m_db.insert(make_pair(word, exp));
                #if DEBUG_SWITCH != 0
                    cerr << __FILE__ << ":" << __FUNCTION__ << " insert pair<" << word << ", ***> to map" << endl;
                #endif // DEBUG_SWITCH
                m_dbc ++;
                word.clear();
                exp.clear();
            }
            word = match_result[1];
            #if DEBUG_SWITCH != 0
                cerr << __FILE__ << ":" << __FUNCTION__ << " match new word<" << word << ">" << endl;
            #endif // DEBUG_SWITCH
            exp.clear();
        }
        else if(regex_match(each_line, match_result, pattern_exp))
        {
            exp.push_back(match_result[2]);
            #if DEBUG_SWITCH != 0
                cerr << __FILE__ << ":" << __FUNCTION__ << " match new explanation<" << match_result[2] << ">" << endl;
            #endif // DEBUG_SWITCH
        }

        if(!fp.good())
            break;
    }
    //flush data to m_db
    if(!word.empty() && !exp.empty())
    {
        m_db.insert(make_pair(word, exp));
        #if DEBUG_SWITCH != 0
            cerr << __FILE__ << ":" << __FUNCTION__ << " insert pair<" << word << ", ***> to map" << endl;
        #endif // DEBUG_SWITCH
        m_dbc ++;
        word.clear();
        exp.clear();
    }
    fp.close();
    return E_SUCCESS;
}

EErrorCode CWordDB::store(const std::string& path)
{
    ofstream of;
    of.open(path.c_str());
    if(!of.good())
    {
        of.close();
        return E_OSERR;
    }
    int cnt = 0;
    for(t_db_cit it0 = m_db.begin(); it0 != m_db.end(); it0++, ++cnt)
    {
        of << cnt << ", " << it0->first << " [null]" << endl;
        t_db_exp exp_list = it0->second;
        for(t_db_exp_cit it1 = exp_list.begin(); it1 != exp_list.end(); it1++)
        {
            of << "adj. " << *it1 << endl;
        }
    }
    of.close();
    return E_SUCCESS;
}

EErrorCode CWordDB::mk_explan(const std::string& word, const std::string& explan)
{
     EErrorCode err = E_ERR;
     if(!word.empty() && !explan.empty())
     {
          t_db_it it = m_db.find(word);
          // word 'word' exists
          if(it != m_db.end())
          {
               // search current explanation list, add if not exists
               t_db_exp &exp = it->second;
               t_db_exp_cit it1 = find(exp.begin(), exp.end(), explan);
               if( it1 == exp.end())
               {
                    exp.push_back(explan);
                    err = E_SUCCESS;
               }
               else
               {
                    err = E_EXPERR;
               }
          }
          // if word 'word' does not exist in m_db, create a new item
          else
          {
               m_db.insert(make_pair(word, list<string>(1, explan)));
               m_dbc ++;
          }
     }
     return err;
}

EErrorCode CWordDB::rm_explan(const std::string& word, const std::string& explan)
{
    EErrorCode err = E_ERR;
    if(!word.empty())
    {
         t_db_it it = m_db.find(word);
         if(it != m_db.end())
         {
              // delete word and its explan from the map
              if(explan.empty())
              {
                   // clean up explan list and then erase word from m_db
                   (it->second).clear();
                   m_db.erase(it);
                   err = E_SUCCESS;
              }
              else
              {

                   // just delete an explan item of the word 'word'
                   t_db_exp &exp = it->second;
                   t_db_exp_it it1 = find(exp.begin(), exp.end(), explan);
                   if( it1 != exp.end())
                   {
                        exp.erase(it1);
                        err = E_SUCCESS;
                   }
                   else
                   {
                        err = E_EXPERR;
                   }
              }
         }
         // if word 'word' does not exist in m_db, just return an abnormal err code
         else
         {
              err = E_WORDERR;
         }
    }
    return err;
}

std::string CWordDB::rd_explan(const std::string& word) const
{
     string sr;

     if(!word.empty() && m_dbc > 0 )
     {
          t_db_cit it = m_db.find(word);
          if(it != m_db.end())
          {
               //collect all explanations items to the result string with a for loop
               const t_db_exp &exp = it->second;
               for(t_db_exp_cit it1 = exp.begin(); it1!= exp.end(); ++it1)
               {
                    sr = sr + *it1 ;
                    if(it1!=exp.end())
                         sr = sr + "\n\r";
               }
          }
     }
     return sr;
}

int CWordDB::get_dbc()
{
    return this->m_dbc;
}

