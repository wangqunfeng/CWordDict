//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : CWordDict
//  @ File Name : cwordserver.cpp
//  @ Date : 2015/2/10
//  @ Author : wangqunfeng
//
//
#include <iostream>
#include <iterator>
#include <string>
#include <list>

#include <cstring>
#include <unistd.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/epoll.h>

#include "cwordconfig.hpp"
#include "eworderror.hpp"
#include "cworddb.hpp"
#include "cwordserver.hpp"

using namespace std;

CWordServer* CWordServer::_instance  = nullptr;
ssize_t CWordServer::_inst_nr = 0;
char CWordServer::m_buff[] = {0};
/** \brief 获取server实例
 *
 * \return CWordServer* 获取到的server实例
 * 系统中只有1个server实例
 */
CWordServer* CWordServer::Instance()
{
    if(_instance == nullptr)
    {
        _instance = new CWordServer();
        _inst_nr = 1;
    }
    else
    {
        _inst_nr++;
    }
    return _instance;
}

/** \brief 私有构造函数，由成员Instance()调用
 */
CWordServer::CWordServer()
{
    m_epfd = -1;
    m_skfd = -1;
    m_lpdb.clear();
}

/** \brief 析构，受控于内部计数器
 */
CWordServer::~CWordServer()
{
    _inst_nr--;
    /**< 如果引用数已为0，则真的销毁server */
    if(_inst_nr == 0)
    {
        CWordDB * pdb = nullptr;
        while(!m_lpdb.empty())
        {
            pdb = m_lpdb.front();
            m_lpdb.pop_front();
            delete pdb;
        }
        delete _instance;
        _instance = nullptr;
    }
}

/** \brief
 *  初始化server，完成两件事情：1.创建epoll；2.创建socket
 * \return EErrorCode
 *
 */
EErrorCode CWordServer::init()
{
    int fd = -1;
    struct sockaddr_in server_addr;

    fd = epoll_create(10); // obsoleted parameter
    if(fd < 0)
    {
        DEBUG_EXIT("epoll_create");
        return E_EPERR;
    }
    this->m_epfd = fd;

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(3600);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    memset(&(server_addr.sin_zero), 0, 8);

    fd = socket(AF_INET, SOCK_STREAM, 0);
    if(-1 == fd)
    {
        DEBUG_EXIT("socket");
        return E_SKERR;
    }
    if(-1 == bind(fd, (struct sockaddr *)&server_addr, sizeof(struct sockaddr)))
    {
        DEBUG_EXIT("bind");
        return E_SKERR;
    }
    if(-1 == listen(fd, 10))
    {
        DEBUG_EXIT("listen");
        return E_SKERR;
    }
    this->m_skfd = fd;

    return E_SUCCESS;
}

/** \brief
 * 启动server。做三件事情：
 * 1.将socket添加到epoll；
 * 2.死循环，执行poll_wait直至异常退出or信号中断
 * 3.接收发起连接的client，并传递给lient_mgr
 * \return EErrorCode
 *
 */
EErrorCode CWordServer::start()
{
    struct epoll_event event_spec;
    memset(&event_spec, 0, sizeof(struct epoll_event));
    event_spec.events = EPOLLIN | EPOLLHUP | EPOLLERR;
    event_spec.data.fd = this->m_skfd;
    if(0 != epoll_ctl(this->m_epfd, EPOLL_CTL_ADD, this->m_skfd, &event_spec))
    {
        DEBUG_INFO("EPOLL_CTL_ADD");
        return E_EPERR;
    }

    struct sockaddr_in client_addr_buf;
    struct epoll_event ev_buf;
    socklen_t client_iplen;
    unsigned int event;
    int fd1, fd2;

    /**< 循环等待接收新用户 */
    while(true)
    {
        if(epoll_wait(m_epfd, &ev_buf, 1, -1) < 0)
        {
            DEBUG_EXIT("epoll_wait");
            return E_EPERR;
        }
        event = ev_buf.events;
        fd1 = ev_buf.data.fd;
        /**< 对于server fd，处理如下 */
        if(fd1 == this->m_skfd)
        {
            /**< 接收新发起连接的client fd，并添加到epoll */
            if(0 !=(EPOLLIN & event))
            {
                fd2 = accept(fd1, (sockaddr *)&client_addr_buf, &client_iplen);
                if(fd2 <0)
                {
                    DEBUG_WARN("accept");
                    continue;
                }
                DEBUG_INFO("client open");
                /**< 发送欢迎消息，同时完成连接测试 */
                if(16 != send(fd2, "Hello, client! ", 16, MSG_DONTWAIT))
                {
                    DEBUG_EXIT("welcome msg send failure");
                    return E_SKERR;
                }

                memset(&ev_buf, 0, sizeof(struct epoll_event));
                ev_buf.events = EPOLLIN | EPOLLHUP | EPOLLERR;
                ev_buf.data.fd = fd2;
                if(0 != epoll_ctl(this->m_epfd, EPOLL_CTL_ADD, fd2, &ev_buf))
                {
                    close(fd2);
                    DEBUG_WARN("EPOLL_CTL_ADD");
                }
            }
            /**< server故障，清除数据，退出 */
            if ((0!=(event &EPOLLHUP))||(0!=(event & EPOLLERR)))
            {
                close(fd1);
                DEBUG_EXIT("server crashed");
                return E_ERR;
            }
        }
        /**< 对于client fd，处理如下 */
        else
        {
            ssize_t nr = 0, nr1 = 0;
            if(0 !=(EPOLLIN & event))
            {
                m_buff[0] = '\0';
                nr = recv(fd1, m_buff, 1024, MSG_DONTWAIT);
                if(nr>0)
                {
                    m_buff[nr] = 0;
                    cout << "got string from client: " << m_buff << endl;
                    nr = this->translate(m_buff, m_buff, 1024,1024);
                    cout << "send string to client back: " << m_buff << endl;
                    if(nr > 0)
                    {
                        /**< 反复写，直到把缓冲区的内容都写完 */
                        do
                        {
                            nr1 = send(fd1, m_buff, nr, MSG_DONTWAIT);
                            if(nr1 <0)
                            {
                                event |= EPOLLERR;
                                break;
                            }
                            else if(nr1 < nr)
                            {
                                nr = nr - nr1;
                            }
                        }while(nr > 0);

                    }
                }
                /**< 读操作发生错误，连接可能已损坏 */
                else if(nr < 0 )
                {
                    event |= EPOLLERR;
                }
            }
            /**< client故障，断开链接 */
            if ((0!=(event &EPOLLHUP))||(0!=(event & EPOLLERR)))
            {
                DEBUG_INFO("client closed");
                close(fd1);
            }
        }
    }

    return E_SUCCESS;
}

/** \brief 加载本地数据库
 *
 * \param path const std::string& 本地数据库文件路径
 * \param dbname const std::string& 数据库名称
 * \return EErrorCode
 *
 */
EErrorCode CWordServer::mk_db(const std::string& path, const std::string& dbname)
{
    CWordDB *db = new CWordDB(dbname);
    if(!db)
        return E_MEMERR;
    EErrorCode err = db->load(path);
    if(err != E_SUCCESS)
    {
        cout << err2str(err) << endl;
        delete db;
        return err;
    }
    //here does not complete db name check, need to repair in the future
    m_lpdb.push_back(db);
    return E_SUCCESS;
}

/** \brief 从内存中移除现有DB
 *
 * \param dbname const std::string& DB名字的引用
 * \return EErrorCode
 *
 */
EErrorCode CWordServer::rm_db(const std::string& dbname)
{
    list<CWordDB*>::iterator it1;
    CWordDB* pdb = nullptr;
    if(dbname.length() > 0)
    {
        for(it1 = m_lpdb.begin(); it1 != m_lpdb.end(); it1++)
        {
            pdb = *it1;
            if(!pdb)
            {
                return E_ERR;
            }
            if(dbname == pdb->get_db_name())
            {
                delete pdb;
                m_lpdb.erase(it1);
                return E_SUCCESS;
            }
        }
        return E_PARAERR;
    }
    else
    {
        while(!m_lpdb.empty())
        {
            pdb = m_lpdb.front();
            m_lpdb.pop_front();
            delete pdb;
        }
        return E_SUCCESS;
    }
}

EErrorCode CWordServer::update_db(const std::string& dbname)
{
    return E_SUCCESS;
}

/** \brief
 * 翻译单词，传回单词翻译结果
 * \param buff1 const char* 单词所在缓冲区
 * \param buff2 char* 解释待入缓冲区
 * \param len1 ssize_t 单词缓冲区长度
 * \param len2 ssize_t  解释缓冲区长度
 * \return int 写入解释缓冲区的长度，0表示未写入，-1表示发生错误
 *
 */
int CWordServer::translate(const char* buff1, char* buff2, unsigned int len1, unsigned int len2)
{
    const string s = buff1;
    string d;
    unsigned int len = 0;
    /**< 遍历词典查找当前单词，当前实现为只查到一条解释就立即返回 */
    for(list<CWordDB*>::iterator it1 = m_lpdb.begin(); it1 != m_lpdb.end(); it1 ++)
    {
        d = (*it1)->rd_explan(s);
        len = d.length() < (len2 -1) ? d.length() : (len2 -1);
        if(len > 0)
        {
            memcpy((void *)buff2, d.c_str(), len);
            buff2[len] = '\0';
            break;
        }
    }
    return len + 1;
}
